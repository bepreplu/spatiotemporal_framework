---
title: "Results"
author: "Matt"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(plotly)
library(astsa)
library(sf)
library(reshape2)
library(gridExtra)
library(transformr)
# library(ape)
sf_use_s2(FALSE)
source("../../../utils/R/utils.R")
install()
library(inlabru)

# helper functions - project wide
source("./helpers.R")
```


load data

```{r include=FALSE}
# define our spatio-temporal coordinates
tcols = c("year", "month")
scols = c("GID_1")
scolsn = c("gid")

# load the country geo data
regions = st_read("../../Brazil/Brazil_1.json")
regions$gid = regionNumber(regions$GID_1)

regions = sfsuspend(regions)
regions = sortdf(regions, scolsn)
regions = sfresume(regions)

# load the baseline data - already sorted by time, then space
snakebites = read.csv(paste(dataFolder,"cleanscaled.csv",sep="/"))[,-1]

# reorder using space first to make copying geometry easy
snakebites = sortdf(snakebites, c(scolsn,tcols))

# note the metrics of the data
times = unique(select(snakebites, tcols))
ntimes = nrow(times)
locs = unique(select(snakebites, scols))
locs = applyLookupv(locs, "GID_1", regions, colsToTransfer=c("NAME_1"))
locs$gid = regionNumber(locs$GID_1)
locs = sortdf(locs, "gid")
nlocs = nrow(locs)

# load the adjacency matrix
adj = readRDS(path("adjacency", folder=dataFolder, extension="rds"))


# Helpers

linmod = function(lmform, data){
  linfit = bru(lmform, family="poisson", data=data,
           options=list(control.compute = list(waic = TRUE, cpo = FALSE),
                        control.inla = list(int.strategy = "eb"),
                        verbose = F))
  linfit$residuals = linfit$residuals$deviance.residuals
  return(linfit)
}

baseform = cases ~ temperature + humidity + rain
covonly = linmod(baseform, data=snakebites)
covonlyresid = covonly$residuals
```

# Initial covariate model - whole country

```{r}
acfallcases = ggacf(snakebites$cases) + ggtitle("ACF plot of all snakebites.")
acfallresids = ggacf(covonlyresid) + ggtitle("ACF plot of initial model's residuals, fit to all snakebites.")

plot(acfallcases)
plot(acfallresids)

saveimg(acfallcases)
saveimg(acfallresids)
```


## Initial covariate model - per region
```{r}
regionNum = 5
regplots = checkRegion(regionNum)
regmap = plotRegion(regions, locs$NAME_1[regionNum], "NAME_1")
plot(regmap)

regcases = regplots$caseplt
regacfcases = regplots$caseacfplt
regacfresid = regplots$residacfplt


saveimg(regmap)
saveimg(regcases)
saveimg(regacfcases)
saveimg(regacfresid)

tabregionuv = data.frame(Cases=regplots$before, Residuals=regplots$after)
tabregionuv$improvement = tabregionuv$Cases - tabregionuv$Residuals

savetbl(tabregionuv, paste("Unexplained autocorrelation in Region",regionNum,""))
```

## Apply an autocorrelation test to all regions

```{r}
## TODO: check that acfUV is same as using new inside outside functions, may be better vectorised.

region = c()
before = c()
after = c()
for(r in 1:nlocs){
  reg = filter(snakebites, gid==r)
  covlm = linmod(baseform, data=reg)
  covresid = covlm$residuals
  
  caseuv = acfUV(reg$cases)
  residuv = acfUV(covresid)
  
  region = c(region, locs[r,2])
  before = c(before, caseuv)
  after = c(after, residuv)
}

covlmUV = data.frame(region, observed=before, residuals=after)
covlmUV$improvement = before - after
covlmUV
savetbl(covlmUV, "Unexplained variance in the observed cases, and in the residuals from the initial linear model.")
```

There are some values which are not well explained by the covariate only model.
```{r}
covlmUV[covlmUV$residuals > covlmUV$observed,]

threshold = .2

covlmUVworst = covlmUV[covlmUV$improvement < threshold,]
covlmUVworst
savetbl(covlmUVworst, caption="Regions where the initial model performed worst.")
```

Conclude that covariates only do not capture all of the variance in all regions.
Suggested improvement - add seasonal term

Region 8:
```{r}
# EspÃ­rito Santo is the problem region (or municipality)
#checkRegion(8)
T
```

```{r}
# where does this come from. One municipality out of what?
#municipalities = st_read("../../Brazil/Brazil_2.json")
#municipalities$reg = regionNumber(municipalities$GID_1)

#santa = filter(municipalities, reg==8)
#ggplotly(plotRegion(municipalities, 8, idCol = "reg"))
T
```

```{r}
# how many cases per municipality from region 8?
```


## Best covariate combination - performance

# Projections
```{r}
measurePredictivePower = function(df, covariates, splitYear, showGraphs=FALSE){
  combinations = comboList(covariates)

  splitAt = firstGTE(df, "year", splitYear) - 1
  split = splitdf(df, splitAt)
  
  perfstat = c()
  for(covs in combinations){
    # make the formula up for each combination of covariates
    hascovs = sum(covs != "") > 0
    lmformula = cases~Intercept(1)
    
    if(hascovs){
      lmformula = form(covariates=c("Intercept(1)",covs))
    }
    
    lmfit = bru(lmformula, family="poisson", data=split$before,
           options=list(control.compute = list(waic = TRUE, cpo = FALSE),
                        control.inla = list(int.strategy = "eb"),
                        verbose = F))
    
    preds = exp(predict(lmfit, newdata=split$after, formula=cleanFormula(lmformula), n.samples=100)$mean)
    
    # measure the performance - rmse
    actual = split$after$cases
    err = actual - preds
    rmse = sqrt(mean(err*err))
    
    if(showGraphs){
      print(ggplotly(ggplot() +
      #geom_line(data=split$before, mapping=aes(x=1:splitAt,y=cases,colour="before")) +
      geom_line(data=split$after, mapping=aes(x=(splitAt+1):nrow(df),y=cases,colour="after")) +
      geom_line(mapping=aes(x=(splitAt+1):nrow(df),y=preds,colour="predicted")) +
      xlab("Held Out Months") +
      ylab("RMSE") +
      ggtitle(paste(covs)) + 
      theme_bw()))
    }
    
    # add to the pile
    perfstat = c(perfstat, rmse)
  }

 return(perfstat)
}
```


Split the data set - fit to past - project future - compare
```{r}
df = snakebites
covlist = c("temperature","humidity","rain")
combinations = comboList(covlist)
comboString = comboListStrings(combinations)

covperflist = list()
bestIndexes = c()
for(i in 1:nlocs){
  reg = locs$GID_1[i]
  print(reg)
  
  regdata = filter(snakebites, GID_1 == reg)
  perfmetric = measurePredictivePower(regdata, covlist, 2018)
  covperflist[[reg]] = perfmetric
  # note the best (lowest)
  bestIndex = which(perfmetric == min(perfmetric))
  bestIndexes = c(bestIndexes, bestIndex)
}


covpredperf = data.frame(covperflist)
covpredperf$covariates = comboString


bestcovpred = data.frame("Region"=locs$NAME_1, "Covariates"=covpredperf$covariates[bestIndexes])

savetbl(covpredperf)
savetbl(bestcovpred)

# get the best per region combo in list format for later use
bestByNum = combinations[bestIndexes]
best = list()
for(i in 1:nlocs){
    reg = locs$GID_1[i]
    best[reg] = bestByNum[i] 
}

```

```{r}
#look at graphs from one region
# i = 4
# 
# reg = locs$GID_1[i]
# print(reg)
# 
# regdata = filter(snakebites, GID_1 == reg)
# perfmetric = measurePredictivePower(regdata, covlist, 2018,showGraphs=T)
# covperflist[[reg]] = perfmetric
# 
# bestIndex = which(perfmetric == min(perfmetric))
# print(comboString[bestIndex])
```






```{r}
# combinations = list(
#     NULL, # is same as observed cases for this first test
#     c("rain"),
#     c("humidity"),
#     c("temperature"),
#     c("rain","humidity"),
#     c("rain","temperature"),
#     c("humidity","temperature"),
#     c("temperature","humidity","rain")
# )
# combinationStrings = unlist(lapply(combinations,FUN=function(item){return(paste(item,collapse=","))}))
# 
# 
# covlmperf = performance(snakebites, locs$GID_1, combinationStrings, 
#                         metric=function(reg, regdata){
#                           row = c()
#                           for(covs in combinations){
#                             # make the formula up for each combination of covariates
#                             lmformula = form()
#                             if(isset(covs)){
#                               lmformula = form(covariates=covs)
#                             }
#                             # fit the linear model
#                             covlm = linmod(lmformula, data=regdata)
#                             # measure it's performance
#                             covresid = covlm$residuals
#                             residuv = acfUV(covresid)
#                             row = c(row, residuv)
#                           }
#                           return(row)
#                         })
# # also find the best combo per region - will this hold true after adding a temporal term? should do because it gives the most explained variance and shows a temporal structure?
# bestIndexes = apply(covlmperf,FUN=function(x){which(x==min(x))},MARGIN=1)
# bestdf = data.frame("Region"=locs$NAME_1, "Covariates"=combinationStrings[bestIndexes])
# 
# best = list()
# for(l in locs$GID_1){
#   row = as.numeric(covlmperf[covlmperf$region==l,-1])
#   bestIndex = which(row==min(row))
#   combo = colnames(covlmperf)[bestIndex+1]# removed region column
#   info(combo)
#   if(combo=="V2"){
#     best[[l]] = NULL
#   }else{
#     best[[l]] = c(strsplit(combo, "\\.")[[1]])
#   }
# }
# 
# 
# savetbl(regionRename(covlmperf), tblname="covlmperf", caption="performance of linear models with different combinations of covariates, by region.")
```

2 points to make: Different covariates perform differently per region.
                  Region 8 performs best with no model (intercept only) - issues with reporting after certain date

Region 8:
```{r}
checkRegion(8, model=form())
```




# Iteration 1 complete - improvements identified (add temporal term, vary covariate combinations)




# Adding temporal term SARIMA


```{r}

# calculate the before and after - performance check. did things improve
sarlmimprove = performance(snakebites, locs$GID_1, c("lmse","smse","diff"), 
              metric = function(reg, regdata){
                # get the best linear model setup
                bestCovs = best[[reg]]
                # fit sarima and linear models for comparison
                sfit = fitSarima(regdata, NULL, covariates=bestCovs, showPlot=FALSE)
                lmfit = linmod(form(covariates=bestCovs), data=regdata)
                # work out the mse and improvement, then output as the next row
                smse = MSE(sfit$resid)
                lmse = MSE(lmfit$residuals)
                diff = lmse - smse
                return(c(lmse,smse,diff))
              }) # yes, big improvements across the board. almost unbelievable. check again to be sure
savetbl(regionRename(sarlmimprove), tblname="sarlmimprove", "Table showing the MSE of the rediduals of a linear model of covariates with and without a temporal SARIMA term")

# select inadequate regions to have an additional AR1 term - look for unexplained t var
sarlmacfchange = performance(snakebites, locs$GID_1, c("initial","sarima","diff"), 
              metric = function(reg, regdata){
                # get the best linear model setup
                bestCovs = best[[reg]]
                # fit sarima and linear models for comparison
                sfit = fitSarima(regdata, NULL, covariates=bestCovs, showPlot=FALSE)
                lmfit = linmod(form(covariates=bestCovs), data=regdata)
                # work out the UV and improvement, then output as the next row
                sm = acfUV(sfit$resid)
                lm = acfUV(lmfit$residuals)
                return(c(lm, sm, lm-sm))
              })
savetbl(regionRename(sarlmacfchange), tblname="sarlmacfchange", "Table showing the unexplained temporal variance of the residuals from a linear model of covariates, as well as a SARIMA model.")
needAR = filter(sarlmacfchange, sarima >= threshold)$region

# fit again with ar1 and sarima for those regions

# check performance increase of those regions over sarima fit
arimprove = performance(snakebites, locs$GID_1, c("sarima","sarimaAR","diff"), 
              metric = function(reg, regdata){
                # get the best linear model setup
                bestCovs = best[[reg]]
                # fit sarima and linear models for comparison
                noar = fitSarima(regdata, NULL, addAR1=F, covariates=bestCovs, showPlot=F)
                ar = fitSarima(regdata, NULL, addAR1=T, covariates=bestCovs, showPlot=F)
                # work out the mse and improvement, then output as the next row
                smse = MSE(noar$resid)
                armse = MSE(ar$resid)
                diff = smse - armse
                row = c(smse,armse,diff)
                info(c(reg,row))
                return(row)
              }) 
arimprove # always an improvement to include the ar1 term. negligable in a number of regions though
savetbl(regionRename(arimprove), tblname="arimprove", "Table showing the MSE in residuals from a SARIMA (0,0,0)(1,0,0)12 model against a SARIMA (1,0,0)(1,0,0)12, as well as the difference.")

# check performance increase of those regions over sarima fit
arimproveuv = performance(snakebites, locs$GID_1, c("sarima","sarimaAR","diff"), 
              metric = function(reg, regdata){
                # get the best linear model setup
                bestCovs = best[[reg]]
                # fit sarima and linear models for comparison
                noar = fitSarima(regdata, NULL, addAR1=F, covariates=bestCovs, showPlot=F)
                ar = fitSarima(regdata, NULL, addAR1=T, covariates=bestCovs, showPlot=F)
                # work out the mse and improvement, then output as the next row
                smse = acfUV(noar$resid)
                armse = acfUV(ar$resid)
                diff = smse - armse
                row = c(smse,armse,diff)
                info(c(reg,row))
                return(row)
              }) 
arimproveuv # always an improvement to include the ar1 term. negligable in a number of regions though
savetbl(regionRename(arimproveuv), tblname="arimproveuv", "Table showing the unexplained variance in residuals from a SARIMA (0,0,0)(1,0,0)12 model against a SARIMA (1,0,0)(1,0,0)12, as well as the difference.")
```

# Sarima performance check - residuals still have temporal pattern?
```{r}
arsaracf = performance(snakebites, locs$GID_1, c("unexplained autocorrelation"), 
              metric = function(reg, regdata){
                # get the best covariates to use
                bestCovs = best[[reg]]
                # fit best model
                ar = fitSarima(regdata, NULL, addAR1=T, covariates=bestCovs, showPlot=F)
                # work out the mse and improvement, then output as the next row
                uv = acfUV(ar$resid)
                return(uv)
              }) 
arsaracf 
```

# get all of the models by region of each type with best covariates
```{r, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, results='hide'}
allfits = colmetric(snakebites, scols, 
              function(reg, regdata){
                # get the best linear model setup
                bestCovs = best[[reg]]
                # fit sarima and linear models for comparison
                sfit = fitSarima(regdata, NULL, addAR1=F, covariates=bestCovs, showPlot=FALSE)
                sarfit = fitSarima(regdata, NULL, addAR1=T, covariates=bestCovs, showPlot=FALSE)
                lmfit = linmod(form(covariates=bestCovs), data=regdata)
                # return the fits
                return(list(linear=lmfit, sarima=sfit, sarimaAR=sarfit))
              })
```


# Is the addition of AR1 significant
Using log likelihood ratio test
```{r}
# arlogratio = listmetric(allfits, function(set, models){
#     sarima = models$sarima
#     sarimaAR = models$sarimaAR
#     
#     logratio = logRat(sarima, sarimaAR)
#     
#     return(c(logratio))
#   }, columnNames=c("logratio","p value","significant", "region"))
# arlogratio$significant = as.logical(arlogratio$significant)
# savetbl(regionRename(arlogratio), tblname="arlogratio")



# change in dic
ardic = listmetric(allfits, function(set, models){
    sarima = models$sarima
    sarimaAR = models$sarimaAR
    
    hasImproved = sarimaAR$dic$dic < sarima$dic$dic

    
    return(c(sarima$dic$dic, sarimaAR$dic$dic, hasImproved))
  }, columnNames=c("sarima", "sarimaAR","improved", "region"))
ardic$improved = as.logical(ardic$improved)
savetbl(regionRename(ardic), tblname="ardic")
```

## Best model per region

```{r results='asis'}
# select the best covariates and best model for each region
bestmodelcols = c("region","temperature","humidity","rain","ar1")
bestmodel = performance(arimprove, locs$GID_1,columns=bestmodelcols, metric=function(reg, data){
    bestcovs = best[[reg]]
    row = c(region=reg,
            temperature = "temperature" %in% bestcovs,
            humidity = "humidity" %in% bestcovs,
            rain = "rain" %in% bestcovs,
            ar1 = T
            )
    return(row)
  })
bestmodel$ar1 = ardic$improved #as.logical(arlogratio$significant)

bestmodel = select(bestmodel,-region.1)

cache(bestmodel)

# change the symbols to more like tick and cross
trueVal = "\\ding{52}"
falseVal = "\\ding{56}"

bestmodel = mutate(bestmodel,
                   temperature=ifelse(temperature==TRUE, trueVal, falseVal),
                   humidity=ifelse(humidity==TRUE, trueVal, falseVal),
                   rain=ifelse(rain==TRUE, trueVal, falseVal),
                   ar1=ifelse(ar1==TRUE, trueVal, falseVal),
                   )

# add something to change cell colour based on value
truefalseColour = function(cell){
  cellColor = "white" 
  if(cell == trueVal){
    cellColor = "teal"
  }
  kableExtra::cell_spec(cell, format="latex", escape=FALSE, background=cellColor)
}

bestmodel = regionRename(bestmodel)
savetbl(bestmodel, caption="Best model for each region.", cellSpecFunc=truefalseColour)
```

## Check back in on Bahia to see the resultant acf
```{r}
regDetails = locs[locs$gid==regionNum,]
regionID = regDetails$GID_1
regionName = regDetails$NAME_1
regionResids = allfits[[regionID]]$sarimaAR$resid

goodacf = ggacf(regionResids)
goodacf

saveimg(goodacf)
```


# Next iteration, why no need to add spatial term?

All the temporal correlation removed therefore independent.

## Variogram of mean residuals
```{r}
# aggregate the residuals over time (mean) per region
meanResids = t(data.frame(lapply(allfits, FUN=function(reg){
    mres = mean(reg$sarimaAR$resid)
    return(mres)
  })))
regions$resid = meanResids

# variogram with confidence intervals - the spatial autocorrelation of the mean residuals
sform = resid~1
v = ggvario(regions, sform=sform, autofit=FALSE)
ci = loadOrGenerate("citable", func=function(){
 return(ggvarioConfidenceIntervals(v$vario, sform=v$sform, sdata=regions, nreps=10000))
},overwrite = FALSE)

# save the plot  
sarimavario = v$plt + ci$ribbon
sarimavario
saveimg(sarimavario)
```


## ST variogram

```{r}
# get the residuals from the AR12 model at time
resids = t(data.frame(lapply(allfits, FUN=function(reg){
    ratt = reg$sarimaAR$resid
    return(ratt)
  })))
colnames(resids) = paste("t",1:ntimes,sep="_")
resids = data.frame(resids)
resids$region = rownames(resids)

# convert to a spatialpointsdataframe
sregions = as_Spatial(regions)
sform = resid~1

# calculate variograms per time bag
bags = ntimes / 12
bagSize = 12
varios = list()
cis = list()
for(i in 0:(bags-1)){
  start = 1 + (i*bagSize)
  end = start + bagSize - 1
  
  print(paste(start, end))
  # the first 1:ntimes columns are the residuals at time t
  meanResids = rowMeans(resids[start:end])
  sregions$resid = meanResids
  
  # calculate just the variogram data, no plot 
  vario = variogram(sform, data=sregions)
  
  
  # now calculate the confidence intervals on a per time bag basis
  ci = ggvarioConfidenceIntervals(vario=vario, 
                                  sform=sform, 
                                  sdata=sregions, 
                                  nreps=10000,
                                  makeRibbon=FALSE)
  # add the ci range to the variogram data
  vario$lb = ci$ci$lb
  vario$ub = ci$ci$ub
  
  # save it
  varios[[(i+1)]] = vario
}

# plot the variograms
varios = bind_rows(varios, .id="time")
varios$time = as.numeric(varios$time)
varios$sig = rep(0, nrow(varios))
varios$sig[isOutside(varios$gamma, varios$lb, varios$ub)] = outside(varios$gamma, varios$lb, varios$ub)


# gamma surface
plot_ly(data=varios, type="mesh3d", x=~time, y=~dist, z=~gamma, 
        autocolorscale=F, colorscale="Viridis")

# ci ranges
plot_ly(data=varios) %>% 
  add_mesh(x=~time, y=~dist, z=~gamma) %>%
  add_mesh(x=~time, y=~dist, z=~lb, color="#FF0251", opacity=.6) %>%
  add_mesh(x=~time, y=~dist, z=~ub, color="#FA2514", opacity=.6) 

# only significant areas
plot_ly(data=varios, type="mesh3d", x=~time, y=~dist, z=~sig, 
        intensity=~sig, autocolorscale=F, colorscale="Hot")


# 2d 
plot_ly(data=varios, type="scatter", mode="markers", x=~time, y=~dist, 
        marker=list(color=~sig,
                    colorscale="Reds",
                    colorbar=list(title="Significance")))


stvario = plot_ly(data=varios, type="contour", x=~time, y=~dist, z=~sig, colorscale="Jet")
stvario
#reticulate::py_run_string("import sys")
#saveimg(stvario)
```

# Disease mapping - current high risk areas
```{r}
sarfits = lapply(allfits, function(region){return(region$sarimaAR)})
```









# Projections

## load the projections - using best model

```{r}
p126 = decache("ssp126")
p245 = decache("ssp245")
p585 = decache("ssp585")
```

## show the trends in set regions - with region overlay
```{r}

# choose some regions to display
displayRegs = c(14,13,6,23)
printed = 
flip = c(13,23)

plts = list()

for(i in 1:nrow(regions)){
  # skip unless we chose this region to display - all is too many for paper
  if(! i %in% displayRegs){
    next
  }
  # look up the best model and region combo one by one
  model = "sarima+AR"    #bestpredModel[i,]$best
  reg = regions$GID_1[i] #bestpredModel[i,]$Region
  regname = regionNameLookup(reg,locs)
  
  # get the data for the given region and best model type
  pred126 = filter(p126, gid==reg)
  pred245 = filter(p245, gid==reg)
  pred585 = filter(p585, gid==reg)

  # plot the general trend in each case
  plotTitle = paste("Region", regname,"-",model,"model")
  regtrend = plot(ggplot() +
        #geom_line(aes(x=ym, y=cases, colour="126"), data=pred126, alpha=0.25) + 
        geom_smooth(aes(x=ym, y=cases, colour="126"), data=pred126, alpha=0.5, se=T) + 
         
         
        #geom_line(aes(x=ym, y=cases, colour="245"), data=pred245, alpha=0.25) +
        geom_smooth(aes(x=ym, y=cases, colour="245"), data=pred245, alpha=0.5, se=T) +
         
        #geom_line(aes(x=ym, y=cases, colour="585"), data=pred585, alpha=0.25) + 
        geom_smooth(aes(x=ym, y=cases, colour="585"), data=pred585, alpha=0.5, se=T) + 
          
        ggtitle(plotTitle) +
        labs(colour="Scenario") +
        theme_bw())
  regtrend = dateAxis(pred126, regtrend, each=10, format="%Y")
  # corner map
  regmap = plotRegion(regions, regId=i, idCol="gid") + ggtitle("") + 
    theme(axis.ticks.x = element_blank(),
          axis.ticks.y = element_blank(),
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          panel.grid = element_blank(),
          panel.border = element_blank(),
          panel.background = element_rect(fill="transparent"),
          plot.background = element_rect(fill="transparent", color = NA))
    
  regplt = gridExtra::grid.arrange(regtrend, regmap, padding = unit(1),
                                   layout_matrix=rbind(
                                      c(2,2,2,1,1,1,1),
                                      c(2,2,2,1,1,1,1),
                                      c(2,2,2,1,1,1,1),
                                      c(1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1)))
  if(i %in% flip){
    regplt = gridExtra::grid.arrange(regtrend, regmap, padding = unit(1),
                                   layout_matrix=rbind(
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                      c(2,2,2,2,2,2,2,1,1,1,1,1,1,1),
                                      c(2,2,2,2,2,2,2,1,1,1,1,1,1,1),
                                      c(2,2,2,2,2,2,2,1,1,1,1,1,1,1),
                                      c(2,2,2,2,2,2,2,1,1,1,1,1,1,1),
                                      c(2,2,2,2,2,2,2,1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1),
                                      c(1,1,1,1,1,1,1,1,1,1,1,1,1,1)))
  }
  
  plot(regplt)
  saveimg(regplt, paste("proj-",regname,sep=""))
}
```



## Disease mapping: show the start-end difference maps per scenario

```{r}

diffs=colmetric(locs, "GID_1", metric=function(reg, row){
  model = "sarima+AR" 
  regname = regionNameLookup(reg,locs)
  
  pred126 = filter(p126, gid==reg)
  pred245 = filter(p245, gid==reg)
  pred585 = filter(p585, gid==reg)
  
  # difference in first and last year mean cases
  diff126 = mean(pred126[pred126$year==max(pred126$year),]$cases) - 
            mean(pred126[pred126$year==min(pred126$year),]$cases)
  
  diff245 = mean(pred245[pred245$year==max(pred245$year),]$cases) - 
            mean(pred245[pred245$year==min(pred245$year),]$cases)
  
  diff585 = mean(pred585[pred585$year==max(pred585$year),]$cases) - 
            mean(pred585[pred585$year==min(pred585$year),]$cases)
  
  vals = list("d126"=diff126,
               "d245"=diff245,
               "d585"=diff585)
  return(vals)
})


regionProj = bind_cols(regions, bind_rows(diffs))

# per scenario average yearly change in snakebites
lowest = min(st_drop_geometry(select(regionProj, d126, d245, d585)))
highest = max(st_drop_geometry(select(regionProj, d126, d245, d585)))

region126plot = ggplot(regionProj) + 
  geom_sf(aes(fill=d126)) +
  scale_fill_gradient2(midpoint=0, low="limegreen", mid="white", high="red3", 
                       limits=c(lowest,highest)) +
  ggtitle("Scenario 126, projected 100 year change in mean annual snakebites") + 
  labs("fill"="Change") +
  theme_bw()
region126plot
saveimg(region126plot)

region245plot = ggplot(regionProj) + 
  geom_sf(aes(fill=d245)) +
  scale_fill_gradient2(midpoint=0, low="limegreen", mid="white", high="red3", 
                       limits=c(lowest,highest)) +
  ggtitle("Scenario 245, projected 100 year change in mean annual snakebites") + 
  labs("fill"="Change") +
  theme_bw()
region245plot
saveimg(region245plot)

region585plot = ggplot(regionProj) + 
  geom_sf(aes(fill=d585)) +
  scale_fill_gradient2(midpoint=0, low="limegreen", mid="white", high="red3", 
                       limits=c(lowest,highest)) +
  ggtitle("Scenario 585, projected 100 year change in mean annual snakebites") + 
  labs("fill"="Change") +
  theme_bw()
region585plot
saveimg(region585plot)

```











